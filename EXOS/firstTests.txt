


%%%% TP 1 %%%%%%%

local
   X
in
   X = 1
   {Browse X}
end
{Browse X}


% Signe d'un nombre
declare
fun {Signe N}
   if (N > 0) then 1
   else
      if (N < 0) then ~1
      else
	 0
      end
   end
end
{Browse {Signe 0}}


%Exo 8

local P Q X Y Z in

   local Y
   in
      Y = X
      fun {P X}
         X*Y + Z
      end
   end
   
   local Z
   in
      Z = Y
      fun {Q Y}
	 X*Y+Z
      end
   end
   
   X=1
   Y=2
   Z=3
   {Browse {P 4}}
   {Browse {Q 4}}
   {Browse {Q {P 4}}}
   {Browse {P Z}}
end


#Exo 9

declare
X = 3

proc {Add2}
   {Browse (X+2)}
end

proc {Mult2}
   {Browse (X*2)}
end

{Add2}
{Mult2}

# PARTIE 2 - EXO 2

declare
fun {Mirror A B}
   
   if (A =< 0) then (B+A)
   else
      {Mirror (A div 10) ((B*10) + (A mod 10))}
   end
end

# PARTIE EXTRA


declare
fun {Aux N M}
   if (M == {Float.toInt {Sqrt {Int.toFloat N}}}) then true
   else
      if ((N mod M) == 0) then false
      else
	 {Aux N M+1}
      end
   end
end

fun {Premier N}
   {Aux N 2}
end

# EXO 4 (Manque PPCM flemme)
declare
fun {PGCD N M}
   if (M == 0) then N
   elseif (N == 0) then M
   else
      if (N >= M) then {PGCD (N mod M) M}
      else
	 {PGCD (M mod N) N}
      end
   end
end

# EXO 6

declare
fun {Compteur N A I}
   if (N == I) then (A+1)
   else
      if ((N mod I) == 0) then {Compteur N A+1 I+1}
      else
	 {Compteur N A I+1}
      end
   end
end

fun {Pave N} {Compteur N 0 1} end

%%%% TP 2 %%%%%%%

%EXO 1
declare
L1=[a]
L2=[a [b c] d]
L3=[proc {$} {Browse oui} end proc {$} {Browse non} end]
L4=[est une liste]
L5=[[a p]]

L6 = '|'(a nil)
L7 = '|'(a '|'('|'(b '|'(c nil))'|'(d nil)))
% L8 = '|' (({proc {$} {Browse oui} end}) '|' ( ({proc {$} {Browse non} end}) nil))
L9 = ceci | L4
{L3.1}
{Browse L2.2}

declare
fun {Head A}
   A.1
end

fun {Tail A}
   A.2
end

%EXO 2

fun {Length A B}
   case A
   of nil then B
   [] H|T then {Length A.2 B+1}
   else
      erreur
   end
end

%EXO 4

declare
fun {PatternMatching A}
   case A
   of nil then empty
   [] H|T then nonEmpty
   else
      other
   end
end

fun {Head A}
   case A
   of nil then empty
   [] H|T then H
   else
      other
   end
end

fun {Tail A}
   case A
   of nil then empty
   [] H|T then T
   else
      other
   end
end
   
fun {Length A B}
   case A
   of nil then B
   [] H|T then {Length A.2 B+1}
   else
      erreur
   end
end


declare
fun {Append A B}
   if (A == nil) then B
   elseif (B == nil) then A
   else
      A.1 | {Append A.2 B}
   end
end

{Browse {Append [r a] [p h]}}


% TP 2 . EXTRA

%1 Flatten

declare
fun {Flatten X}
   fun {FlattenAux X Y}
      if (X == nil) then Y
      else
	 if ({IsList X.1}) then
	    {FlattenAux X.2 {Append Y {FlattenAux X.1 nil}}}
	 else
	    {FlattenAux X.2 {Append Y [X.1]}}
	 end
      end
   end
in
   {FlattenAux X nil}
end

declare
fun {Flatten2 X}
   case X
   of H|T then {Append {Flatten2 H} {Flatten2 T}}
   [] nil then nil
   else
      [X]
   end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

